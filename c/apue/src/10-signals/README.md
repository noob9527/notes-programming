# Chapter10 Signals

## 1. Introduction
skipped

## 2. Signal Concepts
First, every signal has a name. These names all begin with the three characters `SIG`. Signal names are all defined by positive integer constants (the signal number) in the header `<signal.h>`. No signal has a signal number of 0. We'll see in following section that the `kill` function uses the signal number of 0 for a special case. POSIX.1 calls the value the * null signal *.
Numerous conditions can generate a signal:
- The terminal-generated signals occur when user press certain terminal keys.
- Hardware exceptions generate signals: divide by 0, invalid memory reference, and the like. These conditions are usually detected by the hardware, and the kernel is notified. The kernel then generates the appropriate signal for the process that was running at the time the condition occurred.
- The `kill(2)` function allows a process to send any signal to another process or process group. Naturally, there are limitations: we have to be the owner of the process that we're sending the signal to, or we have to be the superuser.
- The `kill(1)` command allows us to send signals to other processes. This program is just an interface to the `kill` function. This command is often used to terminate a runaway background process.
- Software conditions can generate signals when a process should be notified of various events.

We can tell the kernel to do one of three things when a signal occurs. We call this the disposition of the signal, or the action associated with a signal.
1. Ignore the signal. This works for most signals, but two signals can never be ignored: `SIGKILL` and `SIGSTOP`. The reason these two signals can't be ignored is to provide the kernel and the superuser with a surefire way of either killing or stopping any process. Also, if we ignore some of the signals that are generated by a hardware exception, the behavior of the process is undefined.
2. Catch the signal. To do this, we tell the kernel to call a function of ours whenever the signal occurs. In our function, we can do whatever we want to handle the condition. Note that the two signals `SIGKILL` and `SIGSTOP` can't be caught.
3. Let the default action apply. Every signal has a default action. Note that the default action for most signals is to terminate the process.

## 3. `signal` Function
The simplest interface to the signal features of the UNIX System is the `signal` function.
```c
#include <signal.h>

void (*signal(int signo, void (*func)(int)))(int);

// Returns: previous disposition of signal if OK, SIG_ERR on error
```
The `signo` argument is just the name of the signal. The value of `func` is
- The constant `SIG_IGN`.
- The constant `SIG_DFL`.
- The address of a function to be called when the signal occurs.

If we specify `SIG_IGN`, we are telling the system to ignore the signal. When we specify `SIG_DFL`, we are setting the action associated with the signal to its default value. When we specify the address of a function to be called when the signal occurs, we are arranging to "catch" the signal. We call the function either the signal handler or the signal-catching function.\
The prototype for the `signal` function states that the function requires two arguments and returns a pointer to a function that returns nothing(void). The `signal` function's first argument, `signo`, is an integer. The second argument is a pointer to a function that takes a single integer argument and returns nothing. The function whose address is returned as the value of `signal` takes a single integer argument(the final int). In plain English, this declaration says that the signal handler is passed a single integer argument  and that it returns nothing. When we call `signal` to establish the signal handler, the second argument is a pointer to the function. The return value from `signal` is the pointer to the previous signal handler.\
The perplexing `signal` function prototype shown at the beginning of this section can be made much simpler through the use of the following `typedef`
```c
typedef void Sigfunc(int);

Sigfunc *signal(int, Sigfunc *);
```
If we examine the system's header `<signal.h>`, we will probably find declarations of the form
```c
#define SIG_ERR     (void (*)())-1
#define SIG_DFL     (void (*)())0
#define SIG_IGN     (void (*)())1
```
These constants can be used in place of the second argument to `signal`, and the return value from `signal`. The three values of these constants need not be -1, 0 and 1. They must be three values that can never be the address of any declarable function. Most UNIX systems use the values shown.

### Program Start-Up
When a program is executed, the status of all signals is either default or ignore. Normally, all signals are set to their default action, unless the process that calls `exec` is ignoring the signal. Specifically, the `exec` functions change the disposition of any signals being caught to their default action and leave the status of all other signals alone. (Naturally, a signal that is being caught by a process that calls `exec` cannot be caught by the same function in the new program, since the address of the signal-catching function in the caller probably has no meaning in the new program file that is executed.)

### Process Creation
When a process calls `fork`, the child inherits the parent's signal dispositions. Here, since the child starts off with a copy of the parent's memory image, the address of a signal-catching function has meaning in the child.

## 4. Unreliable Signals
In earlier versions of the UNIX System(such as Version 7), signals ere unreliable. By this we mean that signals could get lost: a signal could occur and the process would never know about it. Also, a process had little control over a signal: a process could catch the signal or ignore it. Sometimes, we would like to tell the kernel to block a signal: don't ignore it, just remember if it occurs, and tell us later when we're ready.

## 5. Interrupted System Calls
A characteristic of earlier UNIX systems was that if a process caught a signal while the process was blocked in a "slow" system call, the system call was interrupted. The system call returned an error and `errno` was set to `EINTR`. This was done under the assumption that since a signal occurred and the process caught it, there is a good chance that something has happened that would wake up the blocked system call.\
To support this feature, the system calls are divided into two categories: the "slow" system calls and all the others. The slow system calls are those that can block forever. Included in this category are
- Reads that can block the caller forever if data isn't present with certain file types(pipes, terminal devices, and network devices)
- Writes that can block the caller forever if the data can't be accepted immediately by these same file types.
- Opens on certain file types that block the caller until some condition occurs(such as a terminal device open waiting until an attached modem answers the phone)
- The `pause` function(which by definition puts the calling process to sleep until a signal is caught) and the `wait` function
- Certain `ioctl` operations
- Some of the interprocess communication functions

The notable exception to these slow system calls is anything related to disk I/O. Although a read or a write of a disk file can block the caller temporarily, unless a hardware error occurs, the I/O operation always returns and unblocks the caller quickly.\
To prevent applications from having to handle interrupted system calls, 4.2BSD introduced the automatic restarting of certain interrupted system calls. The system calls that were automatically restarted are `ioctl`, `read`, `readv`, `write`, `writev`, `wait`, and `waitpid`. As we've mentioned, the first five of these functions are interrupted by a signal only if they are operating on a slow device; `wait` and `waitpid` are always interrupted when a signal is caught. Since this caused a problem for some applications that didn't want the operation restarted if it was interrupted, 4.3BSD allowed the process to disable this feature on a per-signal basis.\
One of the reasons 4.2BSD introduced the automatic restart feature is that sometimes we don't know that the input or output device is a slow device. If the program we write can be used interactively, then it might be reading or writing a slow device, since terminals fall into this category. If we catch signals in this program, and if the system doesn't provide the restart capability, then we have to test every read or write for the interrupted error return and reissue the read or write.

## 6. Reentrant Functions
When a signal that is being caught is handled by a process, the normal sequence of instructions being executed by the process is temporarily interrupted by the signal handler. The process then continues executing, but the instructions in the signal handler are now executed. If the signal handler returns(instead of calling `exit` or `longjmp` for example), then the normal sequence of instructions that the process was executing when the signal was caught continues executing. (This is similar to what happens when a hardware interrupt occurs.) But in the signal handler, we can't tell where the process was executing when the signal was caught. What if the process was in the middle of allocating additional memory on its heap using `malloc`, and we call `malloc` from the signal handler? Or, what if the process was in the middle of a call to a function, such as `getpwnam`, that stores it result in a static location, and we call the same function from the signal handler? In the `malloc` example, havoc can result for the process, since `malloc` usually maintains a linked list of all its allocated areas, and it may have been in the middle of changing this list. In the case of `getpwnam`, the information returned to the normal caller can get overwritten with the information returned to the signal handler.\
The Single UNIX Specification specifies the functions that are guaranteed to be safe to call from within a signal handler. These functions are reentrant and are called * sync-signal safe * by the Single UNIX Specification. Besides being reentrant, they block any signals during operation if delivery of a signal might cause inconsistencies. Most of the functions that are not * async-signal safe * because 
- they are known to use static data structures
- they call `malloc` or `free`
- they are part of the standard I/O library

Most implementations of the standard I/O library use global data structures in a nonreentrant way.\
Be aware that even if we call a "async-signal safe" function from a signal handler, there is only one `errno` variable per thread, and we might potentially modify its value. Consider a signal handler that is invoked right after `main` has set `errno`. If the signal handler calls `read`, for example, this call can change the value of `errno`, wiping out the value that was just stored in `main`. Therefore, as a general rule, when calling the functions from a signal handler, we should save and restore `errno`.\
Note that `longjmp` and `siglongjmp` are missing from "async-signal safe" function list, because the signal may have occurred while the main routine was updating a data structure in a nonreentrant way. This data structure could be left half updated if we call `siglongjmp` instead of returning from the signal handler. If it is going to do such things as update global data structures, as we describe here, while catching signals that cause `sigsetjmp` to be executed, an application needs to block the signals while updating the data structures.

## 7. `SIGCLD` Semantics
When this signal occurs, the status of a child has changed, and we need to call one of the `wait` functions to determine what has happened.

## 8. Reliable-Signal Terminology and Semantics
We need to define some of the terms used throughout our discussion of signals. First, a signal is generated for a process when the event that causes the signal occurs. The event could be a hardware exception, a software condition, a terminal-generated signal, or a call to the `kill` function. When the signal is generated, the kernel usually sets a flag of some form in the process table.\
We say that a signal is delivered to a process when the action for a signal is taken. During the time between the generation of a signal and its delivery, the signal is said to be pending.\
A process has the option of blocking the delivery of a signal. If a signal that is blocked is generated for a process, and if the action for that signal is either the default action or to catch the signal, then the signal remains pending for the process until the process either
- unblocks the signal
- changes the action to ignore the signal.

The system determines what to do with a blocked signal when the signal is delivered, not when it's generated. This allows the process to change the action for the signal before it's delivered. The `sigpending` function can be called by a process to determine which signals are blocked and pending.\
What happens if a blocked signal is generated more than once before the process unblocks the signal? POSIX.1 allows the system to deliver the signal either once or more than once. If the system delivers the signal more than once, we say that the signals are queued. Most UNIX systems, however, do not queue signals unless they support the real-time extensions to POSIX.1. Instead, the UNIX kernel simply delivers the signal once.\
What happens if more than one signal is ready to be delivered to a process? POSIX.1 does not specify the order in which the signals are delivered to the process. The Rationale for POSIX.1 does suggest, however, that signals related to the current state of the process be delivered before other signals.\
Each process has a signal mask that defines the set of signals currently blocked from delivery to that process. We can think of this mask as having one bit for each possible signal. If the bit is on for a given signal, that signal is currently blocked. A process can examine and change its current signal mask by calling `sigprocmask`, which we describe in following section.\
Since it is possible for the number of signals to exceed the number of bits in an integer, POSIX.1 defines a data type, called `sigset_t`, that holds a signal set. The signal mask, for example, is stored in one of these signal sets.

## 9. `kill` and `raise` Functions
The `kill` function sends a signal to a process or a group of processes. The `raise` function allows a process to send a signal to itself.
```c
#include <signal.h>

int kill(pid_t pid, int signo);

int raise(int signo);

// Both return: 0 if OK, -1 on error
```
The call `raise(signo)` is equivalent to the call `kill(getpid(), signo)`. There are four different conditions for the `pid` argument to `kill`.
- `pid` > 0 The signal is sent to the process whose process ID is `pid`
- `pid` == 0 The signal is sent to all processes whose process group ID equals the process group ID of the sender and for which the sender has permission to send the signal. Note that the term all processes excludes an implementation-defined set of system processes. For most UNIX systems, this set of system processes includes the kernel processes and `init` (`pid` 1).
- `pid` < 0 The signal is sent to all processes whose process group ID equals the absolute value of `pid` and for which the sender has permission to sen the signal. Again, the set of all processes excludes certain system processes, as described earlier.
- `pid` == -1 The signal is sent to all processes on the system for which the sender has permission to send the signal. As before, the set of processes excludes certain system processes.

As we've mentioned, a process needs permission to send a signal to another process. The superuser can send a signal to any process. One special case for the permission testing also exists: if the signal being sent is `SIGCONT`, a process can send it to any other process in the same session.\
POSIX.1 defines signal number 0 as the null signal. If the `signo` argument is 0, then the normal error checking is performed by `kill`, but no signal is sent. This technique is often used to determine if a specific process still exists. If we send the process the null signal and it doesn't exist, `kill` returns -1 and `errno` is set to `ESRCH`. Be aware, however, that UNIX systems recycle process IDs after some amount of time, so the existence of a process with a given process ID does not necessarily mean that it's the process that you think it is.\
Also understand that the test for process existence is not atomic. By the time that `kill` returns the answer to the caller, the process in question might have exited, so the answer is of limited value.\
If the call to `kill` causes the signal to be generated for the calling process and if the signal is not blocked, either `signo` or some other pending, unblocked signal is delivered to the process before `kill` returns.(Additional conditions occur with threads)

## 10. `alarm` and `pause` Functions
The `alarm` function allows us to set a timer that will expire at a specified time in the future. When the timer expires, the `SIGALRM` signal is generated. If we ignore or don't catch this signal, its default action is to terminate the process.
```c
#include <unistd.h>

unsigned int alarm(unsigned int seconds);

// Returns: 0 or number of seconds until previously set alarm
```
The seconds value is the number of clock seconds in the future when the signal should be generated. When that time occurs, the signal is generated by the kernel, although additional time could elapse before the process gets control to handle the signal, because of processor scheduling delays.\
There is only one of these alarm clocks per process. If, when we call `alarm`, a previously registered alarm clock for the process has not yet expired, the number of seconds left for that alarm clock is returned as the value of this function. That previously registered alarm clock is replaced by the new value.\
If a previously registered alarm clock for the process has not yet expired and if the seconds value is 0, the previous alarm clock is canceled. The number of seconds left for that previous alarm clock is still returned as the value of the function.\
Although the default action for `SIGALRM` is to terminate the process, most processes that use an alarm clock catch this signal. If the process then wants to terminate, it can perform whatever cleanup is required before terminating. If we intend to catch `SIGALRM`, we need to be careful to install its signal handler before calling `alarm`. If we call `alarm` first and are sent `SIGALRM` before we can install the signal handler, our process will terminate.\
The `pause` function suspends the calling process until a signal is caught.
```c
#include <unistd.h>

int alarm(void);

// Returns: -1 with `errno` set to EINTR
```
The only time `pause` returns is if a signal handler is executed and that handler returns. In that case, `pause` returns -1 with `errno` set to `EINTR`.

## 11. Signal Sets
We need a data type to represent multiple signals--a signal set. We'll use this data type with such functions as `sigprocmask` to tell the kernel not to allow any of the signals in the set to occur. As we mentioned earlier, the number of different signals can exceed the number of bits in an integer, so in general we can't use an integer to represent the set with one bit per signal. POSIX.1 defines the data type `sigset_t` to contain a signal set and the following five functions to manipulate signal sets.
```c
#include <signal.h>

int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signo);
int sigdelset(sigset_t *set, int signo);

// All four return: 0 if OK, -1 on error

int sigismember(const sigset_t *set, int signo);

// Returns: 1 if true, 0 if false, -1 on error
```
The function `sigemptyset` initializes the signal set pointed to by set so that all signals are excluded. The function `sigfillset` initializes the signal set so that all signals are included. All applications have to call either `sigemptyset` or `sigfillset` once for each signal set, before using the signal set, because we cannot assume that the C initialization for external and static variables (0) corresponds to the implementation of signal sets on a given system.


## 12. `sigprocmask` Function
ARecall from previous section that the signal mask of a process is the set of signals currently blocked from delivery to that process. A process can examine its signal mask, change its signal mask, or perform both operations in one step by calling the following function
```c
#include <signal.h>

int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);

// Returns: 0 if OK, -1 on error
```

## 13. `sigpending` Function
The `sigpending` function returns the set of signals that are blocked from delivery and currently pending for the calling process. The set of signals is returned through the set argument.
```c
#include <signal.h>

int sigpending(sigset_t *set);

// Returns: 0 if OK, -1 on error
```

## 14. `sigaction` Function
The `sigaction` function allows us to examine or modify (or both) the action associated with a particular signal. This function supersedes the `signal` function from earlier releases of the UNIX System.
```c
#include <signal.h>

int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);

// Returns: 0 if OK, -1 on error
```

## 15. `sigsetjmp` and `siglongjmp` Functions
In previous section, we described the `setjmp` and `longjmp` functions, which can be used for nonlocal branching. The `longjmp` function is often called from a signal handler to return to the main loop of a program, instead of returning from the handler.\
There is a problem in calling `longjmp`, however. When a signal is caught, the signal-catching function is entered, with the current signal automatically being added to the signal mask of the process. This prevents subsequent occurrences of that signal from interrupting the signal handler. If we `longjmp` out of the signal handler, what happens to the signal mask for the process?\
To allow either form of behavior, POSIX.1 does not specify the effect of `setjmp` and `longjmp` on signal masks. Instead, two new functions, `sigsetjmp` and `siglongjmp`, are defined by POSIX.1. These two functions should always be used when branching from a signal handler.
```c
#include <setjmp.h>

int sigsetjmp(sigjmp_buf env, int savemask);

// Returns: 0 if called directly, nonzero if returning from a call to siglongjmp
```
The only difference between theses functions and the `setjmp` and `longjmp` functions is that `sigsetjmp` has an additional argument. If `savemask` is nonzero, then `sigsetjmp` also saves the current signal mask of the process in `env`. When `siglongjmp` is called, if the `env` argument was saved by a call to `sigsetjmp` with a nonzero `savemask`, then `siglongjmp` restores the saved signal mask.

## 16. `sigsuspend` Function
We have seen how we can change the signal mask for a process to block and unblock selected signals. We can use this technique to protect critical regions of code that we don't want interrupted by a signal. But what if we want to unblock a signal and then `pause`, waiting for the previously blocked signal to occur? Assuming that the signal is `SIGINT`, the correct way to do this is
```c
// block SIGINT and save current signal mask

// critical region of code

// restore signal mask, which unblocks SIGINT

// window is open
pause(); // wait for signal to occur
```
If the signal is sent to the process while it is blocked, the signal delivery will be deferred until the signal is unblocked. To the application, this can look as if the signal occurs between the unblocking and the `pause`. If this happens, or if the signal does occur between the unblocking and the `pause`, we have a problem. Any occurrence of the signal in this window of time is lost, in the sense that we might not see the signal again, in which case the `pause` will block indefinitely. This is another problem with the earlier unreliable signals.\
To correct this problem, we need a way to both restore the signal mask and put the process to sleep in a single atomic operation. This feature is provided by the `sigsuspend` function.
```c
#include <signal.h>

int sigsuspend(const sigset_t *sigmask);

// Returns: -1 with errno set to EINTR
```
The signal mask of the process is set to the value pointed to by `sigmask`. Then the process is suspended until a signal is caught or until a signal occurs that terminates the process. If a signal is caught and if the signal handler returns, then `sigsuspend` returns, and the signal mask of the process is set to its value before the call to `sigsuspend`.\
Note that there is no successful return from this function. If it returns to the caller, it always returns -1 with errno set to `EINTR`.

## 17. `abort` Function
We mentioned earlier that the `abort` function causes abnormal program termination.
```c
#include <stdlib.h>

void abort(void);

// This function never returns
```
This function sends the `SIGABRT` signal to the caller. ISO C states that calling `abort` will deliver an unsuccessful termination notification to the host environment by calling `raise(SIGABRT)`.
ISO C requires that if the signal is caught and the signal handler returns, `abort` still doesn't return to its caller. If this signal is caught, the only way the signal handler can't return is if it calls `exit`, `_exit`, `_Exit`, `longjmp`, or `siglongjmp`. POSIX.1 also specifies that `abort` overrides the blocking or ignoreing of the signal by the process.\
The intent of letting the process catch the `SIGABRT` is to allow it to perform any cleanup that it wants to do before the process terminates. If the process doesn't terminate itself from this signal handler, POSIX.1 states that, when the signal handler returns, `abort` terminates the process.

## 18. `system` Function
POSIX.1 requires that `system` ignore `SIGINT` and `SIGQUIT` and block `SIGCHLD`.

### Return Value from `system`
The return value from `system` is the termination status of the shell, which isn't always the termination status of the command string.\
When writing programs that use the `system` function, be sure to interpret the return value correctly. If you call `fork`, `exec` and `wait` yourself, the termination status is not the same as if you call `system`.

## 19. `sleep`, `nanosleep`, and `clock_nanosleep` Functions
We've used the `sleep` function in numerous examples throughout the text
```c
#include <unistd.h>

unsigned int sleep(unsigned int seconds);

// Returns: 0 or number of unslept seconds
```
This function causes the calling process to be suspended until either
1. The amount of wall clock time specified by `seconds` has elapsed
2. A signal is caught by the process and the signal handler returns

As with an `alarm` signal, the actual return may occur at a time later than requested because of other system activity.\
In case 1, the return value is 0. When `sellp` returns early because of some signal being caught(case 2), the return value is the number of unslept seconds(the requested time minus the actual time slept).\
The `nanosleep` function is similar to the `sleep` function, but provides nanosecond-level granularity.
```c
#include <time.h>

int nanosleep(const struct timespec *reqtp, struct timespec *remtp);

// Returns: 0 if slept for requested time or -1 on error
```
With the introduction of multiple system clocks, we need a way to suspend the calling thread using a delay time relative to a particular clock. The `clock_nanosleep` function provides us with this capability.
```c
#include <time.h>

int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *reqtp, sturct timespec *remtp);

// Returns: 0 if slept for requested time or error number on failure
```

## 20. `sigqueue` Function
Generally a signal carries one bit of information: the signal itself. In addition to queueing signals, these extensions allow applications to pass more information along with the delivery. This information is embedded in a `siginfo` structure. Along with system-provided information, applications can pass an integer or a pointer to a buffer containing more information to the signal handler.\
To use queued signals we have to do the following:
1. Specify the `SA_SIGINFO` flag when we install a signal handler using the `sigaction` function. If we don't specify this flag, the signal will be posted, but it is left up to the implementation whether the signal is queued.
2. Provide a signal handler in the `sa_sigaction` member of the `sigaction` structure instead of using the usual `sa_handler` field. Implementations might allow us to use the `sa_handler` field, but we won't be able to obtain the extra information sent with the `sigqueue` function.
3. Use the `sigqueue` function to send signals

```c
#include <signal.h>

int sigqueue(pid_t pid, int signo, const union sigval value);

// Returns: 0 if OK, -1 on error
```
The `sigqueue` function is similar to the `kill` function, except that we can only direct signals to a single process with `sigqueue`, and we can use the value argument to transmit either an integer or a pointer value to the signal handler.

## 21. Job-Control Signals
POSIX.1 considers six to be job-control signals:
- `SIGCHLD` Child process has stopped or terminated.
- `SIGCONT` Continue process, if stopped.
- `SIGSTOP` Stop signal
- `SIGTSTP` Interactive stop signal.
- `SIGTTIN` Read from controlling terminal by background process group member.
- `SIGTTOU` Write to controlling terminal by a background process group member.

Except for `SIGCHLD`, most application programs don't handler these signals: interactive shells usually do all the work required to handler them.

## 22. Signal Names and Numbers
In this section, we describe how to map between signal numbers and names. Some systems provide the array
```c
extern char *sys_siglist[];
```
The array index is the signal number, giving a pointer to the character string name of the signal.\
To print the character string corresponding to a signal number in a portable manner, we can use the `psignal` function.
```c
#include <signal.h>

void psignal(int signo, const char*msg);
```
The string `msg` is output to the standard error, followed by a colon and a space, followed by a description of the signal, followed by a newline.\
If you only need the string description of the signal and don't necessarily want to write it to standard error, you can use the `strsignal` function.
```c
#include <string.h>

char *strsignal(int signo);

// Returns: a pointer to a string describing the signal
```

## 23. Summary
skipped
